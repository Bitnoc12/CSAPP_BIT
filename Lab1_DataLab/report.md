# 一、实验目的
本实验目的是加强学生对位级运算的使用能力。
# 二、报告要求
本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，
也可以是代码分析，根据实现中你的想法不同而异。
# 三、函数分析
1. bitXor函数     
**函数要求：**
* 使用~和&实现x^y
* 示例：bitNor(0x4,0x5) = 0x1
* 限制操作：~ &
* 操作数量：14
* 难度：1

**实现分析：**
这题的思路是使用离散数学的知识对其进行推导得出只有~和&就能实现异或的功能。

**函数实现：**
```
int bitXor(int x, int y) {
    return (~(x & y)) & (~((~x) & (~y)));
}
```

2. getByte函数
**函数要求：**
* 获取x的第n字节
* 示例：getByte(0x12345678,1) = 0x56
* 限制操作：! ~ & ^ | + << >>
* 操作数量：6
* 难度：2

**实现分析：**
首先将进入函数的n进行变化，由于给定的n是一个字节，左移右移是以位进行运算，因此创建了一个变量byteToBit将n*8转换成位存储，最后将x右移byteToBit最后将其与0xff进行&操作从而获得指定字节的值。

**函数实现：**
```
int getByte(int x, int n) {
        int byteToBit = n<<3;
        return (x>>byteToBit)&0xff;
}
```

3. logicalShift函数
**函数要求：**
* 计算x逻辑右移n位
* 说明：0 <= n <= 31
* 示例：logicalShift(0x87654321,4) = 0x08765432
* 限制操作：! ~ & ^ | + << >>
* 操作数量：20
* 难度：3

**实现分析：**
首先必须先了解到系统内“>>”的右移是属于算术右移。这题我采取的是使用内置的算术右移与自制的掩码将其进行与操作从而得到逻辑右移。

**函数实现：**
```
int logicalShift(int x, int n) {
        int mask =(((~(1<<31))>>n)<<1)+1;
        return (x>>n)&mask;
}
```

4. bitCount函数 
**函数要求：**
* 计算二进制数中1的个数
* 示例：bitCount(7) = 3
* 限制操作：! ~ & ^ | + << >>
* 操作数量：40
* 难度：4

**实现分析：**
这里通过一系列位操作和分治算法实现，首先构建了三种掩码以处理不同位数的1，然后分别计算每个字节、16位块和4位块中1的个数，并将结果累积。最后，将累积结果的每个字节相加，确保返回的结果是8位，即一个字节。精彩的是分治算法，这部分结合了二分的思想和掩码的设计。

**函数实现：**
```
int bitCount(int x) {
        //sum of 1 in x
        int count;
        //build mask
        int mask1 = 0x55;
        int mask2 = 0x33;
        int mask3 = 0x0F;
        mask1 = mask1|(mask1<<8);
        mask1 = mask1|(mask1<<16);
        mask2 = mask2|(mask2<<8);
        mask2 = mask2|(mask2<<16);
        mask3 = mask3|(mask3<<8);
        mask3 = mask3|(mask3<<16);
        //fenzhi algorithm
        count = (x & mask1) + ((x>>1) & mask1);
        count = (count & mask2) + ((count>>2) & mask2);
        count = (count & mask3) + ((count>>4) & mask3);
        return (count + (count>>8) + (count>>16) + (count>>24)) & 0xff;
}
```

5. conditional函数 
**函数要求：**
* 实现x?y:z
* 示例：conditional(2,4,5) = 4
* 限制操作：! ~ & ^ | + << >>
* 操作数量：16
* 难度：3

**实现分析：**
函数内部采用了位操作和掩码来实现条件选择。首先，通过!!x将x转换为0或1，然后将其左移31位并右移31位，生成一个全0或全1的掩码mask，即如果x为真，则mask为全1，否则为全0。最后，利用mask进行按位与和按位或操作，根据x的真假返回y或z，即当x为真时返回y，当x为假时返回z。

**函数实现：**
```
int conditional(int x, int y, int z) {
        int mask =(!!x)<<31>>31;
        return (mask&y)|(~mask&z);
}
```

6. tmin函数 
**函数要求：**
* tmin - 返回最小的补码整数
* 合法操作：! ~ & ^ | + << >>
* 最大操作数：4
* 评级：1

**实现分析：**
在补码表示中，最小的整数是负的，它的二进制表示中只有最高位为1，其余都是0。因此，将1左移31位得到了这个数。在补码表示中，最高位是符号位，所以这是一个负数，这里直接利用位移操作返回了最小的补码整数。

**函数实现：**
```
int tmin(void) {
  return 1<<31;
}
```

7. fitsBits函数 
**函数要求：**
* 判断x是否能用n位补码表示
* 说明：1 <= n <= 32
* 示例：fitsBits(5,3) = 0
* 限制操作：! ~ & ^ | + << >>
* 操作数量：15
* 难度：2

**实现分析：**
计算一个位偏移量bit，将x左移bit位再右移bit位，然后与x异或。如果结果为0，表示x可以用n位表示，返回1；否则返回0。这个函数丢弃超过n位的部分，仅保留最低的n位，然后检查是否与原值x相等。如果相等，表示x没有超过n位的有效位数。

**函数实现：**
```
int fitsBits(int x, int n) {
        int bit = 33 + (~n);
        return !((x<<bit>>bit)^x);
}
```

8. dividePower2函数 
**函数要求：**
* 计算x/(2^n)，divpwr2
* 说明：0 <= n <= 30
* 示例：dividePower2(-33,4) = -2
* 限制操作：! ~ & ^ | + << >>
* 操作数量：15
* 难度：2

**实现分析：**
首先确定x的符号，然后根据符号计算一个偏置值。最后，将偏置加到x上，然后右移n位，实现除法并向零舍入。这个函数适用于正数和负数。

**函数实现：**
```
int dividePower2(int x, int n) {
        int sign = x>>31;
        int bias = sign & ((1<<n)+(~0));
        return (x+bias)>>n;
}
```

9. negate函数 
**函数要求：**
* 计算-x
* 示例：negate(1) = -1
* 限制操作：! ~ & ^ | + << >>
* 操作数量：5
* 难度：2

**实现分析：**
这里通过按位取反~和加1操作实现

**函数实现：**
```
int negate(int x) {
        return (~x)+1;
}
```

10. howManyBits函数 
**函数要求：**
* 判断x需要多少为补码表示
* 示例：howManyBits(12) = 5
* 限制操作：! ~ & ^ | << >>
* 操作数量：90
* 难度：4

**实现分析：**
这里的思想是将负数取反转换成跟正数一样的问题去处理，算法核心是需要找到最高位的1。howManyBits函数计算整数x的二进制表示中所需的位数。通过位操作和分治算法实现，首先确定x的符号，然后迭代地检查不同位数的1的个数，最终返回所需的位数。

**函数实现：**
```
int howManyBits(int x) {
        int sign = x>>31;
        int bit_16,bit_8,bit_4,bit_2,bit_1,bit_0;
        x = (sign&(~x))|(~sign&x);
        bit_16 = (!!(x>>16))<<4;
        x = x>>bit_16;
        bit_8 = (!!(x>>8))<<3;
        x = x>>bit_8;
        bit_4 = (!!(x>>4))<<2;
        x = x>>bit_4;
        bit_2 = (!!(x>>2))<<1;
        x = x>>bit_2;
        bit_1 = !!(x>>1);
        x = x>>bit_1;
        bit_0 = x;
        return bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + 1;
}
```

11. isLessOrEqual函数
**函数要求：**
* 判断x<=y
* 示例：isGreater(4,5) = 1
* 限制操作：! ~ & ^ | + << >>
* 操作数量：24
* 难度：3

**实现分析：**
其实现逻辑非常巧妙，首先获取了x和y的符号位（signX和signY），然后计算y - x的符号位（signY_X），最终通过位运算组合这些符号位，以确定是否x小于或等于y。如果x的符号位为负且y的符号位为正，或者x和y的符号位相同且y - x为非正数（signY_X为非负数），则返回1，表示x小于或等于y；否则返回0，表示x大于y。这个函数的实现非常紧凑，通过位运算快速判断大小关系。

**函数实现：**
```
int isLessOrEqual(int x, int y) {
        int signX = x>>31;
        int signY = y>>31;
        int signY_X = (y+(~x)+1)>>31;
        return (signX&!signY)|(!(signX^signY)&!signY_X);
}
```

12. intLog2函数 
**函数要求：**
* 计算floor(log2(x))
* 说明：x>0
* 示例：intLog2(16) = 4
* 限制操作：! ~ & ^ | + << >>
* 操作数量：90
* 难度：4

**实现分析：**
这题的算法思想跟howManyBit类似。intLog2函数旨在计算整数x的以2为底的对数（向下取整），即找到最高位1的位置。其逻辑非常简洁，通过迭代，首先检查16位、8位、4位、2位和1位的位置是否有1，逐步将位数的权重累积到bit_16、bit_8、bit_4、bit_2和bit_1。最终，这些累积的权重相加，即bit_16+bit_8+bit_4+bit_2+bit_1，得到了最高位1的位置，即x的对数。这个函数实现了高效的对数计算，不需要循环，而是通过位操作快速找到最高位的位置。

**函数实现：**
```
int intLog2(int x){
        int bit_16,bit_8,bit_4,bit_2,bit_1;
        bit_16 = (!!(x>>16))<<4;
        x = x>>bit_16;
        bit_8 = (!!(x>>8))<<3;
        x = x>>bit_8;
        bit_4 = (!!(x>>4))<<2;
        x = x>>bit_4;
        bit_2 = (!!(x>>2))<<1;
        x = x>>bit_2;
        bit_1 = (!!(x>>1));
        x = x>>bit_1;
        return bit_16+bit_8+bit_4+bit_2+bit_1;
}
```

13. floatAbsVal函数 
**函数要求：**
* 返回浮点数f的绝对值
* 说明：若参数为NaN，返回该参数
* 限制操作：所有整数相关操作，||，&&，if，while
* 操作数量：10
* 难度：2

**实现分析：**
floatAbsVal函数的逻辑首先检查输入浮点数uf是否为NaN，通过检查指数字段是否全为1和uf左移9位后是否不等于0。如果是NaN，直接返回uf，否则使用按位与操作将uf的符号位清零，得到其绝对值，然后返回。这个函数能有效地处理浮点数的符号位，确保最终结果为非负值。

**函数实现：**
```
unsigned floatAbsVal(unsigned uf) {
        //check float is nan
        if((uf & 0x7f800000)>>23 == 255 && uf<<9)
                return uf;
        return uf & 0x7fffffff;
}
```

14. floatScale1d2函数 
**函数要求：**
* 计算浮点数0.5*f
* 说明：若参数为NaN，返回参数
* 限制操作：所有整数相关操作 || && if while
* 操作数量：30
* 难度：4

**实现分析：**
floatScale1d2函数实现了对浮点数uf进行除以2的操作。首先，提取浮点数的指数部分(exp)和符号位(s)，然后进行条件检查，处理NaN和无穷大的情况。如果exp大于1，函数将减小exp并重新组合成浮点数，实现除以2。如果uf的尾数为3，将uf加2，然后右移1位并保留最低23位，最后再将符号位添加回去，实现了浮点数的舍入到最近偶数的除以2操作。这个函数处理了多种情况，确保对输入浮点数进行准确的除以2操作。

**函数实现：**
```
unsigned floatScale1d2(unsigned uf) {
        int exp = (uf & 0x7f800000)>>23;
        int s = uf&0x80000000;
        if((uf & 0x7fffffff) >= 0x7f800000)
                return uf;
        if(exp > 1)
                return (uf&0x807fffff)|(--exp)<<23;
        if((uf & 0x3)==0x3)
                uf = uf + 0x2;
        return ((uf>>1)&0x007fffff)|s;
}
```

15. floatFloat2Int函数 
**函数要求：**
* 将浮点数转换为有符号整数，float_f2i
* 说明：超出整形范围(NaN和无穷大)返回0x80000000
* 限制操作：所有整数相关操作 || && if while
* 操作数量：30
* 难度：4

**实现分析：**
floatScale1d2函数的实现可以分成几个步骤。首先，将浮点数uf分成三部分：符号部分sign_，指数部分exp_，和小数部分frac_。符号部分直接右移31位获取，指数部分通过掩码和偏移操作获取，小数部分则是提取尾数并补上了浮点数默认的"1"。然后，函数处理特殊情况。如果exp_和frac_都为0，那么返回0。如果exp_大于31，表示整数无法表示，发生溢出，直接返回0x80000000。如果exp_小于0，表示该浮点数处于0和1之间，直接返回0。接下来，函数根据指数部分的大小来调整小数部分的值。如果exp_大于23，将小数部分左移exp_ - 23位。如果exp_小于23，将小数部分右移23 - exp_位。最后，函数考虑符号位。对于正数，不需要额外处理。对于负数，如果小数部分frac_为正数，需要根据符号部分sign_来调整正负，最终返回结果。如果小数部分frac_为负数，唯一正确的结果是0x80000000，表示负无穷大。这个函数的实现考虑了浮点数的各种特殊情况，以确保对输入浮点数进行准确的除以2操作。

**函数实现：**
```
int floatFloat2Int(unsigned uf) {
        int exp = ((uf&0x7f800000)>>23)-127;
        int s = uf>>31;
        int frac = (uf&0x007fffff)|0x00800000;
        if(!(uf&0x7fffffff)) return 0;
        if(exp>31) return 0x80000000;
        if(exp<0) return 0;

        if(exp>23) frac<<=(exp-23);
        else frac>>=(23-exp);

        if(!((frac>>31)^s)) return frac;
        else if(frac>>31) return 0x80000000;
        else return ~frac+1;
}
```
# 实验心得
在实验中，我面临了两个主要困难。首先，我对实验环境不够熟悉，初始时出现了许多错误，耗费了大量时间来解决。此外，在虚拟环境中无法直接输入中文，导致撰写实验报告变得困难。最后，我使用了剪切板同步的方法来克服这个问题。此外，学习并应用Markdown格式也需要花费不少时间，因此我建议将实验环境和报告撰写分开处理，以降低复杂性。

其次，在算法方面，大多数问题并不难，但是对于像bitCount、howManyBits和intLog这些需要使用二分思想的题目，我花费了相当多的时间来理解和掌握。然而，一旦掌握了这些技巧，我感到非常有成就感。总的来说，这个实验让我学到了许多知识，我非常喜欢这种既包含理论又有实际操作的课程，因为它有助于更好地掌握知识并将其应用于实践中。
